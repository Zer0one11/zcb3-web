<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>ZCB3 - RE3 Macro Renderer</title>
    <style>
        body { background: #0e0e12; color: #fff; font-family: sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; }
        .box { background: #1c1c24; padding: 30px; border-radius: 15px; text-align: center; border: 1px solid #333; width: 400px; }
        .drop-zone { border: 2px dashed #5865f2; padding: 40px; border-radius: 10px; cursor: pointer; margin: 20px 0; transition: 0.3s; }
        .drop-zone:hover { background: rgba(88, 101, 242, 0.1); }
        .btn { background: #5865f2; color: white; padding: 12px 20px; border: none; border-radius: 5px; cursor: pointer; text-decoration: none; display: none; font-weight: bold; }
        #log { font-size: 12px; color: #888; margin-top: 10px; }
    </style>
</head>
<body>

<div class="box">
    <h2 style="color: #5865f2;">ZCB3 RE3 RENDERER</h2>
    <div class="drop-zone" id="dropZone">Кликни или перетащи .re3 файл</div>
    <input type="file" id="fileInput" style="display: none;">
    <div id="log">Ожидание файла...</div>
    <a id="dl" class="btn">СКАЧАТЬ АУДИО (.WAV)</a>
</div>

<script>
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const log = document.getElementById('log');
    const dl = document.getElementById('dl');

    dropZone.onclick = () => fileInput.click();
    fileInput.onchange = (e) => processReplay(e.target.files[0]);

    async function processReplay(file) {
        if (!file) return;
        log.innerText = "Парсинг бинарных данных...";
        const buffer = await file.arrayBuffer();
        const view = new DataView(buffer);
        
        let offset = 0;

        // 1. Читаем TPS (float32)
        const tps = view.getFloat32(offset, true);
        offset += 4;

        // 2. Читаем размеры (4 шт uint32)
        const p1_phys_size = view.getUint32(offset, true); offset += 4;
        const p2_phys_size = view.getUint32(offset, true); offset += 4;
        const p1_input_size = view.getUint32(offset, true); offset += 4;
        const p2_input_size = view.getUint32(offset, true); offset += 4;

        log.innerText = `TPS: ${tps} | Кликов: ${p1_input_size}`;

        // 3. Пропускаем физические данные (они нам не нужны для звука)
        // Структура replay_data занимает 4(int) + 4(float) + 4(float) + 4(float) + 8(double) + 1(bool) = 25 байт.
        // НО: из-за выравнивания в C++ (padding) размер структуры может быть 32 байта.
        const REPLAY_DATA_SIZE = 32; 
        offset += (p1_phys_size + p2_phys_size) * REPLAY_DATA_SIZE;

        // 4. Читаем инпуты (replay_data2)
        // Структура: frame(4), down(1), button(4), isPlayer1(1). С учетом выравнивания ~12 байт.
        const INPUT_DATA_SIZE = 12; 
        const clickTimes = [];

        for (let i = 0; i < p1_input_size; i++) {
            const frame = view.getUint32(offset, true);
            const isDown = view.getUint8(offset + 4) !== 0;
            
            if (isDown) {
                clickTimes.push(frame / tps);
            }
            offset += INPUT_DATA_SIZE;
        }

        renderAudio(clickTimes);
    }

    async function renderAudio(times) {
        if (times.length === 0) { log.innerText = "Кликов не найдено!"; return; }
        
        const sampleRate = 44100;
        const duration = times[times.length - 1] + 1;
        const ctx = new OfflineAudioContext(1, sampleRate * duration, sampleRate);

        // Создаем звук клика
        const clickBuff = ctx.createBuffer(1, sampleRate * 0.1, sampleRate);
        const cd = clickBuff.getChannelData(0);
        for(let i=0; i<cd.length; i++) cd[i] = Math.exp(-i/400) * Math.sin(i/8);

        times.forEach(t => {
            const s = ctx.createBufferSource();
            s.buffer = clickBuff;
            s.connect(ctx.destination);
            s.start(t);
        });

        const rendered = await ctx.startRendering();
        const wav = bufferToWav(rendered);
        const url = URL.createObjectURL(new Blob([wav], {type:'audio/wav'}));
        
        dl.href = url;
        dl.style.display = 'inline-block';
        log.innerText = "Рендеринг завершен!";
    }

    // Стандартный конвертер в WAV
    function bufferToWav(abuffer) {
        let n = abuffer.numberOfChannels, len = abuffer.length*n*2+44, buf = new ArrayBuffer(len), v = new DataView(buf), chs = [], i, s, off = 0, p = 0;
        const u16 = (d) => { v.setUint16(p, d, true); p += 2; }, u32 = (d) => { v.setUint32(p, d, true); p += 4; };
        u32(0x46464952); u32(len-8); u32(0x45564157); u32(0x20746d66); u32(16); u16(1); u16(n);
        u32(abuffer.sampleRate); u32(abuffer.sampleRate*2*n); u16(n*2); u16(16); u32(0x61746164); u32(len-p-4);
        for(i=0; i<n; i++) chs.push(abuffer.getChannelData(i));
        while(p < len) { for(i=0; i<n; i++) { s = Math.max(-1, Math.min(1, chs[i][off])); v.setInt16(p, s < 0 ? s*0x8000 : s*0x7FFF, true); p += 2; } off++; }
        return buf;
    }
</script>
</body>
</html>
